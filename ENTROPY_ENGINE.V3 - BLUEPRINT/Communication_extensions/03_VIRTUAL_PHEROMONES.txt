================================================================================
VIRTUAL PHEROMONES (Spatial Markers) - Implementation Plan
================================================================================

GOAL:
Agenti mohou zanechat zprávy na souřadnicích (X, Y). Ostatní agenti je přečtou,
když projdou poblíž. Asynchronní komunikace bez přímého kontaktu.

================================================================================
1. CONFIGURATION CHANGES
================================================================================

File: entropy/config.py

Add to CommConfig:
    pheromones_enabled: bool = False
    pheromone_radius: float = 50.0    # Detection range
    pheromone_ttl: int = 100          # Time-to-live (steps)
    max_pheromones: int = 50          # Max markers in world (buffer size)
    pheromone_dim: int = 8            # Message vector size (can be same as msg_dim)

================================================================================
2. WORLD STATE EXTENSION
================================================================================

File: entropy/core/world.py

Add new fields to WorldState:

    @dataclass
    class WorldState:
        # ... existing fields ...
        
        # Pheromone Buffer [max_pheromones, ...]
        pheromone_positions: jnp.ndarray  # [P, 2] - X, Y
        pheromone_messages: jnp.ndarray   # [P, pheromone_dim]
        pheromone_ttls: jnp.ndarray       # [P] - Remaining steps
        pheromone_valid: jnp.ndarray      # [P] - Is slot occupied?
        pheromone_write_ptr: int          # Circular buffer pointer

================================================================================
3. ACTION SPACE EXTENSION
================================================================================

File: entropy/training/env_wrapper.py

Current Action:
    [Motor(2), Gate(1), Channel(1), Angle(1), Dist(1), Msg(D)]

Proposed Action:
    [Motor(2), Gate(1), Channel(1), Angle(1), Dist(1), Msg(D), PlaceMarker(1)]
    
    PlaceMarker > 0.5: Agent places a pheromone at current position with Msg.

OR simpler approach:
    Channel = 2 means "Place Marker" (extend existing Channel logic)
    - Channel 0: Direct
    - Channel 1: Broadcast
    - Channel 2: Pheromone (place at Target Point)

================================================================================
4. PHEROMONE LOGIC
================================================================================

File: NEW - entropy/core/pheromones.py

    def place_pheromone(state, agent_id, position, message, config):
        """Add pheromone to world state buffer."""
        ptr = state.pheromone_write_ptr
        
        new_positions = state.pheromone_positions.at[ptr].set(position)
        new_messages = state.pheromone_messages.at[ptr].set(message)
        new_ttls = state.pheromone_ttls.at[ptr].set(config.pheromone_ttl)
        new_valid = state.pheromone_valid.at[ptr].set(True)
        
        new_ptr = (ptr + 1) % config.max_pheromones
        
        return state.replace(
            pheromone_positions=new_positions,
            pheromone_messages=new_messages,
            pheromone_ttls=new_ttls,
            pheromone_valid=new_valid,
            pheromone_write_ptr=new_ptr
        )
    
    def decay_pheromones(state):
        """Reduce TTL and invalidate expired markers."""
        new_ttls = state.pheromone_ttls - 1
        new_valid = state.pheromone_valid & (new_ttls > 0)
        return state.replace(pheromone_ttls=new_ttls, pheromone_valid=new_valid)
    
    def read_nearby_pheromones(state, agent_positions, config):
        """
        For each agent, find pheromones within radius.
        Returns: [N, K_pheromones, pheromone_dim] or flattened.
        """
        # Distances: [N_agents, P_pheromones]
        dists = jnp.linalg.norm(
            agent_positions[:, None, :] - state.pheromone_positions[None, :, :],
            axis=-1
        )
        
        in_range = (dists < config.pheromone_radius) & state.pheromone_valid[None, :]
        
        # Gather messages for each agent (masked)
        # Option: Return closest K pheromones per agent
        # Option: Return aggregated (mean) pheromone signal
        
        # Simple aggregation:
        weights = in_range.astype(jnp.float32)
        weights = weights / (weights.sum(axis=1, keepdims=True) + 1e-6)
        
        aggregated = jnp.einsum('np,pd->nd', weights, state.pheromone_messages)
        return aggregated  # [N, pheromone_dim]

================================================================================
5. OBSERVATION SPACE EXTENSION
================================================================================

File: entropy/training/env_wrapper.py

Add pheromone signal to observation:

    def _get_obs(self, state, inbox_msgs, inbox_meta, inbox_mask):
        # ... existing obs ...
        
        if cfg.comm.pheromones_enabled:
            pheromone_signal = read_nearby_pheromones(
                state, state.agent_positions, cfg.comm
            )
            return jnp.concatenate([obs, pheromone_signal], axis=-1)
        else:
            return obs

Update obs_dim calculation:
    if self.use_comms:
        inbox_size = K * (self.msg_dim + 3 + 1)
        pheromone_size = self.comm_cfg.pheromone_dim if self.comm_cfg.pheromones_enabled else 0
        self.obs_dim = lidar + 4 + inbox_size + pheromone_size

================================================================================
6. STEP LOGIC UPDATE
================================================================================

File: entropy/training/env_wrapper.py (step method)

    def step(self, state, actions, rng):
        # 1. Physics
        motor_actions = actions[:, :2]
        next_state = physics_step(state, motor_actions)
        
        # 2. Communication (Direct/Broadcast)
        # ... existing comms_router logic ...
        
        # 3. Pheromones
        if cfg.comm.pheromones_enabled:
            # Decay existing pheromones
            next_state = decay_pheromones(next_state)
            
            # Place new pheromones
            # Assuming Channel=2 means pheromone
            channel = actions[:, 3]
            is_placing = channel > 1.5  # Channel index 2
            
            # For each agent placing a marker:
            for i, placing in enumerate(is_placing):
                if placing:
                    target_point = compute_target_point(actions[i], state.agent_positions[i])
                    message = actions[i, 6:6+pheromone_dim]
                    next_state = place_pheromone(next_state, i, target_point, message, cfg.comm)
        
        # ... rest of step ...

================================================================================
7. VISUALIZATION
================================================================================

File: entropy/render/cpu_renderer.py

Add pheromone rendering:

    def draw_pheromones(self, frame, state, config):
        for i in range(config.max_pheromones):
            if state.pheromone_valid[i]:
                pos = state.pheromone_positions[i]
                ttl_ratio = state.pheromone_ttls[i] / config.pheromone_ttl
                
                # Fading circle
                color = (0, 255, 255)  # Cyan
                alpha = ttl_ratio * 0.5
                
                cv2.circle(frame, self.to_pix(pos), 
                          int(config.pheromone_radius * self.scale),
                          color, 1)

================================================================================
8. VERIFICATION PLAN
================================================================================

Test 1: Placement & Decay
    - Agent places pheromone
    - Verify it appears in world state
    - After TTL steps, verify it disappears

Test 2: Reading
    - Agent A places pheromone at (100, 100)
    - Agent B moves to (120, 100)
    - Verify B's observation contains pheromone signal

Test 3: Behavioral Impact
    - Scenario: Maze exploration
    - Agent A marks dead end
    - Agent B reads mark and avoids dead end
    - Compare: With vs without pheromones

================================================================================
9. ESTIMATED EFFORT
================================================================================

- World State extension:  1 hour
- Pheromone logic:        2 hours
- Env wrapper integration: 2 hours
- Visualization:           1 hour
- Testing:                 1-2 hours

TOTAL: ~7-8 hours

================================================================================
10. DEPENDENCIES
================================================================================

- Requires: Spatial Communication (DONE)
- Requires: Target Point calculation (DONE)
- Optional: Grid-based pheromones for efficiency (future optimization)

================================================================================
